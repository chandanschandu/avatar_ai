<!DOCTYPE html>
<html lang="en">
<head>
  <title>Chandan S - AI Portfolio</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body, html {
      width: 100%; height: 100%;
      margin: 0; padding: 0;
      background-color: #121212; color: #E0E0E0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden; display: flex; flex-direction: column;
    }
    #header { background:#1E1E1E; padding:15px 30px; border-bottom:1px solid #333; text-align:center; }
    #header h1 { margin:0; font-size:2em; color:#fff; }
    #header .links a { color:#BB86FC; text-decoration:none; margin:0 10px; font-size:1em; }
    #header .links a:hover { text-decoration:underline; }
    #main-container { display:flex; flex:1; overflow:hidden; }
    #avatar-container {
      flex:1; display:flex; justify-content:center; align-items:center; min-width:50%; pointer-events:none;
      background-image: url('images/bg.jpg');
      background-size: cover;
      background-position: center;
    }
    #avatar { width:100%; height:100%; max-width:900px; max-height:900px; }
    #chat-container { flex:1; background:#1E1E1E; border-left:1px solid #333; display:flex; flex-direction:column; padding:20px; box-sizing:border-box; max-width:500px; }
    #chat-messages { flex:1; overflow-y:auto; padding-right:10px; margin-bottom:15px; min-height: 0; }
    .message { margin-bottom:15px; padding:10px 15px; border-radius:18px; max-width:85%; line-height:1.4; }
    .message.user { background:#373737; color:#E0E0E0; align-self:flex-end; border-bottom-right-radius:4px; margin-left:auto; }
    .message.bot { background:#BB86FC; color:#121212; align-self:flex-start; border-bottom-left-radius:4px; }
    #chat-input-container { display:flex; border-top:1px solid #333; padding-top:15px; }
    #chat-input { flex:1; background:#373737; color:#E0E0E0; border:1px solid #555; border-radius:20px; padding:10px 15px; font-size:1em; outline:none; }
    #send-button, #stop-button, #mic-button {
      border:none; border-radius:50%; width:40px; height:40px;
      cursor:pointer; font-size:1.2em;
      display:flex; justify-content:center; align-items:center;
      margin-left: 10px;
    }
    #send-button { background:#BB86FC; color:#121212; }
    #send-button:hover { background:#a06cd5; }
    #stop-button { background:#ff6b6b; color:#121212; display:none; }
    #stop-button:hover { background:#e05252; }
    #mic-button { background: #6c757d; color: #fff; }
    #mic-button.listening { background: #dc3545; }
    #loading { position:absolute; bottom:10px; left:10px; font-size:16px; background:rgba(0,0,0,0.5); padding:5px; border-radius:3px; }
    .past-word { opacity:0.6; }
    .current-word { background:#FFD54F; color:#121212; padding:2px 4px; border-radius:4px; }
    .future-word { opacity:0.3; }

    @media (max-width: 768px) {
      #main-container {
        flex-direction: column;
      }
      #avatar-container {
        flex: 0 0 45%; /* Don't grow, don't shrink, basis of 45% */
        min-height: 0; /* Allow shrinking if needed */
        min-width: 100%;
      }
      #chat-container {
        max-width: 100%;
        border-left: none;
        border-top: 1px solid #333;
        flex: 1 1 auto; /* Grow and shrink as needed */
        min-height: 0; /* Allow shrinking */
        display: flex; /* Ensure flex properties apply to children */
        flex-direction: column;
      }
      #header h1 {
        font-size: 1.5em;
      }
      #header .links a {
        font-size: 0.9em;
      }
      #chat-input {
        padding: 8px 12px;
        font-size: 0.9em;
      }
      #send-button, #stop-button, #mic-button {
        width: 35px;
        height: 35px;
        font-size: 1em;
      }
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js/+esm",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
        "talkinghead": "https://cdn.jsdelivr.net/gh/met4citizen/TalkingHead@1.5/modules/talkinghead.mjs"
      }
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>

 
  <script type="module">
  import { TalkingHead } from "talkinghead";

  const visemeMap = ["sil","aa","aa","O","E","RR","I","U","O","O","O","I","kk","RR","nn","SS","CH","TH","FF","DD","kk","PP"];
  let head, microsoftSynthesizer = null;
  let visemesbuffer = {}, prevViseme = null;
  let currentBotMessageElem = null;
  let speechStartTime = 0;
  let synthesisInProgress = false;
  let abortController = new AbortController();
  let recognition, isListening = false;

  // Word scheduling
  let wordSchedule = []; // { text, time(ms), scheduled:boolean }
  let scheduledTimers = []; // timeout ids

  function resetLipsyncBuffers() {
    visemesbuffer = { visemes: [], vtimes: [], vdurations: [] };
    prevViseme = null;
  }

  function clearScheduledTimers() {
    for (const t of scheduledTimers) clearTimeout(t);
    scheduledTimers = [];
  }

  // ----------------- UPDATED SCHEDULE FUNCTION -----------------
  // Tune this to match your avatar/audio pipeline delay
  const playbackLatencyMs = 400;  

  function scheduleWord(idx, chatMessages) {
    const w = wordSchedule[idx];
    if (!w || w.scheduled) return;
    w.scheduled = true;

    // Target display time = speechStartTime + audioOffset + latency
    const displayAt = speechStartTime + w.time + playbackLatencyMs;
    const delay = Math.max(0, displayAt - performance.now());

    const tid = setTimeout(() => {
      if (!synthesisInProgress || !currentBotMessageElem) return;
      currentBotMessageElem.textContent += (currentBotMessageElem.textContent ? " " : "") + w.text;
      if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
    }, delay);

    scheduledTimers.push(tid);
  }

  function schedulePendingWords(chatMessages) {
    for (let i = 0; i < wordSchedule.length; i++) {
      if (!wordSchedule[i].scheduled) scheduleWord(i, chatMessages);
    }
  }
  // ---------------------------------------------------------------

  resetLipsyncBuffers();

  document.addEventListener('DOMContentLoaded', async () => {
    const nodeAvatar = document.getElementById('avatar');
    const nodeLoading = document.getElementById('loading');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');
    const stopButton = document.getElementById('stop-button');
    const micButton = document.getElementById('mic-button');

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.lang = 'en-US';
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        const transcript = event.results[event.results.length - 1][0].transcript.trim();
        chatInput.value = transcript;
        handleUserMessage();
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (isListening) stopListening();
      };

      recognition.onend = () => {
        micButton.classList.remove('listening');
        micButton.textContent = 'ðŸŽ¤';
      };

      micButton.addEventListener('click', () => {
        if (isListening) stopListening();
        else startListening();
      });
    } else {
      micButton.style.display = 'none';
      addMessage("Sorry, your browser does not support voice recognition.", "bot");
    }

    function startListening() {
      if (SpeechRecognition && !synthesisInProgress && !isListening) {
        isListening = true;
        micButton.classList.add('listening');
        micButton.textContent = '...';
        try { recognition.start(); } catch (e) { console.error("Error starting recognition:", e); stopListening(); }
      }
    }

    function stopListening() {
      if (SpeechRecognition) {
        isListening = false;
        micButton.classList.remove('listening');
        micButton.textContent = 'ðŸŽ¤';
        try { recognition.stop(); } catch (e) {}
      }
    }

    nodeLoading.textContent = "Loading Avatar...";
    head = new TalkingHead(nodeAvatar, { ttsEndpoint: "/gtts/", cameraView: "upper", lipsyncLang: "en" });

    try {
      await head.showAvatar(
        { url: "https://models.readyplayer.me/68c22c1a8ac0d37a66b6df1c.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown&textureSizeLimit=1024&textureFormat=png", body: "F" },
        (ev) => { if (ev.lengthComputable) nodeLoading.textContent = `Loading ${Math.round((ev.loaded / ev.total) * 100)}%`; }
      );
      nodeLoading.style.display = "none";
      await initializeAzureTTS();
      startConversation();
    } catch (err) {
      console.error("Error loading avatar:", err);
      nodeLoading.textContent = "Failed to load avatar.";
    }

    function startStreamingSession() {
      if (!head.isStreaming) {
        head.streamStart({
          sampleRate: 48000, mood: "happy", gain: 0.5,
          lipsyncType: "visemes", lipsyncLang: "en",
          waitForAudioChunks: true, metrics: { enabled: true, intervalHz: 2 }
        });
      }
    }

    function textToSSML(text) {
      return `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><voice name="en-US-GuyNeural">${text}</voice></speak>`;
    }

    async function initializeAzureTTS() {
      if (microsoftSynthesizer) return;
      try {
        const response = await fetch('/api/tts-token');
        const token = await response.json();
        const config = window.SpeechSDK.SpeechConfig.fromSubscription(token.key, token.region);
        config.speechSynthesisOutputFormat = window.SpeechSDK.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm;
        microsoftSynthesizer = new window.SpeechSDK.SpeechSynthesizer(config, null);

        microsoftSynthesizer.synthesizing = (s, e) => {
          if (speechStartTime === 0) speechStartTime = performance.now();
          head.streamAudio({
            audio: e.result.audioData,
            visemes: visemesbuffer.visemes.splice(0),
            vtimes: visemesbuffer.vtimes.splice(0),
            vdurations: visemesbuffer.vdurations.splice(0)
          });
          schedulePendingWords(chatMessages);
        };

        microsoftSynthesizer.visemeReceived = (s, e) => {
          const vtime = e.audioOffset / 10000;
          const viseme = visemeMap[e.visemeId];
          if (!head.isStreaming) return;
          if (prevViseme) {
            let vduration = vtime - prevViseme.vtime;
            if (vduration < 40) vduration = 40;
            visemesbuffer.visemes.push(prevViseme.viseme);
            visemesbuffer.vtimes.push(prevViseme.vtime);
            visemesbuffer.vdurations.push(vduration);
          }
          prevViseme = { viseme, vtime };
        };

        microsoftSynthesizer.wordBoundary = (s, e) => {
          if (!synthesisInProgress) return;
          const timeMs = e.audioOffset / 10000;
          const idx = wordSchedule.length;
          wordSchedule.push({ text: e.text, time: timeMs, scheduled: false });
          if (speechStartTime !== 0) scheduleWord(idx, chatMessages);
        };

      } catch (err) {
        console.error("initializeAzureTTS error:", err);
      }
    }

    function azureSpeak(ssml, botMessageElem) {
      clearScheduledTimers();
      wordSchedule = [];
      speechStartTime = 0;
      currentBotMessageElem = botMessageElem;
      synthesisInProgress = true;

      if (!microsoftSynthesizer) initializeAzureTTS().catch(console.error);

      try {
        microsoftSynthesizer.speakSsmlAsync(
          ssml,
          () => {
            if (currentBotMessageElem) {
              currentBotMessageElem.textContent = wordSchedule.map(w => w.text).join(' ') || currentBotMessageElem.textContent;
            }
            clearScheduledTimers();
            wordSchedule = [];
            currentBotMessageElem = null;
            synthesisInProgress = false;

            const checkSpeakingInterval = setInterval(() => {
              if (!head.isSpeaking) {
                clearInterval(checkSpeakingInterval);
                stopButton.style.display = 'none';
                sendButton.style.display = 'flex';
                micButton.style.display = 'flex';
                resetLipsyncBuffers();
                if (isListening) startListening();
              }
            }, 100);
          },
          (err) => { console.error("Azure TTS error:", err); resetAllState(); }
        );
      } catch (err) { console.error("speakSsmlAsync exception:", err); resetAllState(); }
    }

    function addMessage(text, sender) {
      const el = document.createElement('div');
      el.classList.add('message', sender);
      el.textContent = text;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return el;
    }

    async function handleUserMessage() {
      const text = chatInput.value.trim();
      if (text && !synthesisInProgress) {
        addMessage(text, 'user'); chatInput.value = '';
        stopButton.style.display = 'flex';
        sendButton.style.display = 'none';
        micButton.style.display = 'none';

        const response = await getBotResponse(text);
        if (response === "Generation stopped.") {
          addMessage("Process stopped by user.", 'bot');
          resetAllState();
          return;
        }

        const botEl = addMessage("", 'bot');
        const ssml = textToSSML(response);
        if (!head.isStreaming) startStreamingSession();
        azureSpeak(ssml, botEl);
      }
    }

    function resetAllState() {
      synthesisInProgress = false;
      currentBotMessageElem = null;
      speechStartTime = 0;
      clearScheduledTimers();
      wordSchedule = [];
      stopButton.style.display = 'none';
      sendButton.style.display = 'flex';
      micButton.style.display = 'flex';
      resetLipsyncBuffers();
    }

    sendButton.addEventListener('click', handleUserMessage);
    chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleUserMessage(); });

    stopButton.addEventListener('click', async () => {
      synthesisInProgress = false;
      clearScheduledTimers();
      wordSchedule = [];

      try { if (microsoftSynthesizer) { microsoftSynthesizer.close(); microsoftSynthesizer = null; } } catch (err) { console.error(err); }
      try { head.streamNotifyEnd(); } catch (e) { console.error(e); }

      if (currentBotMessageElem) currentBotMessageElem.textContent += " â€¦Stopped.";
      currentBotMessageElem = null;
      stopButton.style.display = 'none';
      sendButton.style.display = 'flex';
      micButton.style.display = 'flex';
      resetLipsyncBuffers();
      initializeAzureTTS().catch(console.error);
    });

    function startConversation() {
      const welcome = "Hello! I'm an AI avatar representing Chandan S. You can ask me about his skills, experience, projects, or anything else you'd like to know.";
      addMessage(welcome, 'bot');
    }

    async function getBotResponse(userInput) {
      abortController = new AbortController();
      try {
        const res = await fetch("/v1/chat", {
          method: "POST",
          signal: abortController.signal,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: userInput })
        });

        const data = await res.json();
        if (data && data.choices && data.choices[0] && data.choices[0].message) {
          // Remove markdown characters like '*', '_', '#', '-' from the response
          return data.choices[0].message.content.replace(/[*_#-]/g, '');
        }
        return "Sorry, I couldnâ€™t generate a response.";
      } catch (err) {
        if (err.name === "AbortError") return "Generation stopped.";
        console.error(err);
        return "Oops! Something went wrong.";
      }
    }
  });
</script>

</head>
<body>
  <div id="header">
    <h1>Chandan S - AI Portfolio</h1>
  </div>
  <div id="main-container">
    <div id="avatar-container">
      <div id="avatar"></div>
      <div id="loading"></div>
    </div>
    <div id="chat-container">
      <div id="chat-messages"></div>
      <div id="chat-input-container">
        <input type="text" id="chat-input" placeholder="Type or press ðŸŽ¤ to talk...">
        <button id="send-button" title="Send">&#9658;</button>
        <button id="mic-button" title="Activate Voice">ðŸŽ¤</button>
        <button id="stop-button" title="Stop Speaking">&#9632;</button>
      </div>
    </div>
  </div>
</body>
</html>

